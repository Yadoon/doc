
## 1.0 需求背景

当前场景:当前复盘报告在保存和编辑时概率出现保存失败和数据丢失，暂无稳定复现方式。所以需要修改当前报告创建和编辑的方式。

## 2.0 方案对比

### 2.0.1 原方案

创建报告时使用项目Id，报告类型，用户Id组成唯一标识绑定数据到协同服务，此时这部分数据可充当个人的草稿使用，实时保存。

![[旧创建编辑报告流程.drawio.png]]

==创建报告将collection的名字通过mongo CMD转为mysql主键，此时会概率触发保存失败问题==，sharedb-mongo对象支持mongo的query语句查询，但是原则上不应该接收封装外的编辑操作或者新增操作。[sharedb-mongo文档](https://github.com/share/sharedb-mongo)
### 2.0.2 新方案

~~业务服务收到创建报告请求时额外添加一个唯一标识符，并将标识符与mysql索引进行映射，保存到mongodb中，后续编辑和查询时~~
~~以便在单个文档上协作。~~
创建报告：用户的每一次创建报告都会在参数上追加uid，此时每一份报告都是唯一的，可协同的。任何改动的数据都会被记录，其他用户可以看到这份报告已经在列表列表中，可以通过编辑入口参与协同编辑。并提供针对完整报告的被动快照机制和手动快照机制，保障用户数据的安全性和灵活性。
编辑报告：通过唯一id订阅报告组件，参与协同编辑报告。
查询报告：单报告查询，通过唯一id查询报告，列表查询，根据项目ID，报告类型，作者等参数筛选报告。

### 2.0.3 破坏性变更需求设计

#### 2.0.3.0 创建报告

原设计现状：创建复盘报告时以用户个人身份创建一份报告，编辑的内容只有自己可见取消或刷新后内容一直存在，只要不使用创建按钮保存报告，这份报告只有自己可见。当点击创建按钮后，数据保存到mysql报告内容所有人可见，可编辑，个人再次点击创建报告会获得一份空的新“个人报告”。
![[Pasted image 20250313155717.png]]
![[Pasted image 20250313160046.png]]
缺点风险：
	1. 创建报告时有小概率创建失败，因mongoDB引发，暂无稳定复现方式。[MongoDBIssue](https://jira.mongodb.org/browse/GODRIVER-3496)
	2. 协同程度低，用户编辑了一些数据后才可见，其中可能包含部分相关必填项，可能需要其他用户协助，阻塞编辑进程。

重构方案：变更mysql的数据结构到mongoDB，每次点击“创建报告”都会新增一条所有人可见可编辑的报告，将创建报告时所用的参数（项目ID，报告类型，~~用户ID~~）修改为（项目ID，报告类型，==版本ID，十三位当前时间戳==），每份报告都具有唯一性。同时在report_metadata中维护全部报告的元信息，此项与报告的查询，编辑，删除相关。
原mysql的report数据结构
![[Pasted image 20250313163813.png]]

mongoDB中重构后的的数据从mysql的tb_report被拆分为report_content和report_metadata

1. report_content保存报告内容实时变更的bug_data,bug_num等数据 ![[Pasted image 20250313164130.png]]
2. report_metadata保存报告增删改查行为相关的元信息
 ![[Pasted image 20250313164330.png]]




#### 2.0.3.0 查询报告

原设计现状：根据项目id和报告类型查询报告列表，如果查询具体某个报告，会同步mongoDB报告中的conetent内容，覆盖mysql中的数据。
缺点风险：
	1. 原设计预设mongoDB中的数据总是领先于mysql，那么数据总是一致的。但是当出现协同服务因网络问题断开连接的情况，mongoDB中数据无法及时更新，而用户编辑数据后保存到了mysql，再次查询就会出现使用mongoDB中的“老数据”覆盖mysql中的“新数据”问题。（[补丁实装TMP-915](https://www.zhugeliang.work/task/TMP-915)：ws断开连接时提示用户重新连接，阻止断连用户保存数据到mysql)

方案一：当前的新建报告设计已经将数据保存到mongoDB,使用原生的mongo聚合搜索,查询效率高。

方案二：如果原生的mongo聚合和搜索collection无法实现时，使用 正则筛选collection并通过go的channel获取到全部报告信息，在进行筛选
3.协同编辑时展示同时参与编辑的用户
方案一：用户参与编辑或退出编辑时server通过websocket推送当前channel的正在编辑的用户
方案二：按时间隔查询channl中的用户
4.倒序展示报告的全部更新记录
方案一：获取操作collection倒序分页
5.获取历史版本报告的对比数据趋势

6.报告的删除
方案一：删除的权限校验，删除时校验当前是否有用户正在编辑，删除的形式回收站


## 2.0主流产品调研
首先,我们应当明确协同编辑功能的特性.你不能只让每个人自己工作，然后合并每个人的副本或选取最后一次编辑。用户实际上应该可以看到对方正在做什么，并获得即时反馈。

### 2.1.1 Google Docs

Google Docs 是基于云盘系统扩展的办公系统，具有一系列功能，包括文档存储，共享，格式化，编辑等.系统有以下几个主要部分:
- 文件存储:由于 Google 文档是 Google 云端硬盘的一部分，因此也包含了存储功能。该系统允许用户将文件（文档）分组到文件夹，并支持编辑/创建/删除等功能。它更像一个操作系统。
- 在线编辑和格式化:毫无疑问，Google 文档的核心功能之一就是在线编辑。它支持几乎所有的微软 Office 操作。
- 协同编辑:Google Docs 允许多个人同时编辑单个文档
- 访问控制:你可以与你的朋友分享文档，并给予不同的权限（所有者，只读，允许评论等）。

Google docs的协同编辑基于版本控制实现,每次修改都会对文档创建一个版本,并显示diff,你可以查看文档的历史版本并选择保存.
服务器可以为每个人保留量份相同的文档，并跟踪完整的修订历史。当 A 通过在开头添加`x`来编辑文档时，这个改变将与 A 所看到的最后修订一起发送到服务器。假设此时 B 删除最后一个字符`c`，并且这个改变也是这样发送到服务器。

由于服务器知道修改在哪个版本上进行，因此会相应地调整更改。更具体地说，B 的变化是删除第三个字符`c`，它将被转换为删除第四个字符，因为 A 在开头添加了`x`。

这就是所谓的操作转换（Operational Tranformation）基本思想是根据修改和其他合作者的修改来转换每个人的改动。

goole docs 编辑页面
![[Pasted image 20240710095231.png]]



### 2.1.2 飞书云文档

飞书是一款国产综合性的办公协作平台产品,飞书云文档在前端设计简洁，取消了传统工具栏，采用隐藏式工具栏，提供简洁的白纸样式编辑界面，旨在让用户专注于内容创作,用户目前使用的产品就是飞书.

在协同编辑功能上使用了和Google Docs相似的云盘加OT方案,在持久化方面也同样使用了版本控制的方式存储文件和相关信息

飞书历史版本页面
![[Pasted image 20240710095330.png]]


### 2.1.3 冲突处理OT与CRDT

在线文档实时协同编辑的难点之一在于协同冲突处理,OT算法是解决协同冲突处理的主要方案.

#### 2.1.3.1 编辑锁

当有人在编辑某个文档时，系统会将这个文档锁定，避免其他人同时编辑。编辑锁的实现方式简单粗暴，但会直接影响用户体验。

#### 2.1.3.2 diff-patch

基于 Git 等版本管理类似的思想，对内容进行差异对比、合并等操作，包括 GNU diff-patch、Myer’s diff-patch 等方案。diff-patch 可以对冲突进行自助合并，也可以在冲突出现时交给用户处理。

#### 2.1.3.3 最终一致性实现

包括 Operational Transformation（OT）、 Conflict-free replicated data type(CRDT，称为无冲突可复制数据类型)。OT 算法是 石墨文档，腾讯文档，飞书文档，Google Docs 中所采用的方案，Atom 编辑器使用的则是 CRDT。

  
#### 2.1.3.4 OT 和 CRDT

OT 和 CRDT 两种方法的相似之处在于它们提供最终的一致性。不同之处在于他们的操作方式：

- OT 通过更改操作来做到这一点
- OT 会对编辑进行操作的拆分、转换，实现冲突处理的效果
- OT 并不包括具体的实现，因此需要项目自行实现，但可以根据项目需要进行高精度的冲突处理
- CRDT 通过更改状态来做到这一点
- 基本上，CRDT 是数据结构，当使用相同的操作集进行更新时，即使这些操作以不同的顺序应用，它们始终会收敛在相同的表示形式上
- CRDT 有两种方法：基于操作和基于状态

对于富文本编辑等更高级的结构，OT 用复杂性换来了对用户预期的实现，而 CRDT 则更加关注数据结构，随着数据结构的复杂度上升，算法的时间和空间复杂度也会呈指数上升的，会带来性能上的挑战。因此，如今大多数实时协同编辑都基于 OT 算法来实现。

## 3.0 总结

### 3.1 场景对比
当前场景的对象为5KB左右的json,可以使用websoket根据固定的json结构更新的方式来实现,缺点是缺乏扩展性.
OT不仅适用纯文本、JSON数据,也能兼容各种富文本,有更多可扩展的空间.CRDT维护成本过高,所以选用shareddb存储.

Simple realtime client/server sync with ShareDB
![[demo.gif]]



参考链接
https://github.com/share/sharedb
https://www.cnblogs.com/WindrunnerMax/p/17114099.html
https://operational-transformation.github.io/index.html
https://zhuanlan.zhihu.com/p/692480370