# 内部协同知识库平台 (Project: Wiki-Next) - 技术方案文档

> **文档版本**: 1.1
> **创建日期**: 2025-08-14
> **最后更新**: 2025-08-14
> **作者**: [汪李旸]

## 1. 项目背景与目标

### 1.1. 背景

当前，团队与项目间的知识沉淀分散，缺乏一个统一、高效的文档协作平台。项目文档、会议纪要、技术方案等散落在各自的电脑或零散的共享目录中，难以查找、复用和进行有效的协同创作。

### 1.2. 目标

为了解决以上痛点，我们计划构建一个内部协同知识库平台 (代号: Wiki-Next)，旨在：

1.  **统一知识入口**：为所有项目组提供一个集中化的知识管理与沉淀平台。
2.  **提升协作效率**：支持多人实时在线编辑文档，消除版本冲突和反复的文件传输。
3.  **融入现有生态**：与公司已有的**账号中心**和**项目中心**无缝集成，实现统一的身份认证和权限管理。
4.  **对标业界标杆**：在功能和体验上，参考业界优秀的知识库产品（如**语雀**），提供流畅、强大的文档编辑与管理体验。

## 2. 技术选型与方案分析

为了实现一个功能强大、体验优秀且与公司现有系统深度融合的协同知识库，我们对业界多种主流的解决方案进行了调研、原型搭建与横向对比。

### 2.1. 核心技术路线对比

1. **组件集成路线**: 引入一个成熟的、开箱即用的协同编辑应用作为 `<iframe>` 组件。
2. **框架自研路线 (CRDT)**: 基于 Y.js 等 CRDT 库，配合 Tiptap 等“无头”编辑器，构建高度定制化的原生协同体验。
3. **框架自研路线 (OT)**: 基于 ShareDB 等 OT 框架，深度集成富文本编辑器，构建企业级协同后端。


### 2.2. 开箱即用方案调研 (组件集成路线)

#### 2.2.1. Etherpad
- **简介**: 开源的、功能专注的协同富文本编辑器应用。
- ![[Pasted image 20250807173559.png]]
- **优点**:
    - **开箱即用**: 自带稳定、功能丰富的前端编辑器和成熟的协同后端，极大降低了开发成本。
    - **开发成本低**: 部署简单，通过 API 和 `<iframe>` 即可快速集成。
    - **功能完备**: 原生支持用户身份识别、版本历史回放、聊天等协同等功能。
    - **生态成熟**: 拥有庞大的插件库，可轻松扩展表格、Markdown、评论等功能。
    - **易于集成**: API 简单清晰，主要工作集中在权限和会话管理，而非复杂的协同逻辑。
- **缺点**:
	- **定制性中等**: UI 和核心交互逻辑难以深度修改，无法完全达到语雀级的精致体验。
	- **非原生体验**: `<iframe>` 嵌入方式在加载、滚动、弹窗等方面存在固有的体验割裂感。
	- **插件有兼容性问题**:简单使用demo验证插件安装会出错。
#### 2.2.2. Outline
- **简介**: 一个现代化的、开源的知识库平台，功能对标 Notion/Confluence。
- ![[Pasted image 20250807172059.png]]
- **优点**:
	- **开发成本低**: 开箱即用，提供了完整的知识库管理、权限体系、模板、搜索等功能。
	- **UI/UX 优秀**: 界面美观、交互流畅，是本项目理想的对标产品。
	- **协同基于 ProseMirror**: 底层技术先进，协同编辑体验非常出色。
- **缺点**:
	- **几乎零定制**: Outline 是一个**高度集成的完整产品**，而非一个可嵌入的“组件”。我们难以将其与公司现有的账号中心、项目中心进行深度业务逻辑融合。它更适合作为一个独立的系统使用。
	- **技术栈复杂**: 其后端基于 Node.js, React, aPostgreSQL, Redis 等，自托管和二次开发的门槛高。
#### 2.2.3. CKEditor 5
- **简介**: 一款历史悠久、功能强大的商业富文本编辑器，提供协同编辑的付费功能。
- ![[Pasted image 20250807172140.png]]
- **优点**:
	- **功能全面且稳定**: 提供了非常丰富的富文本编辑功能，如表格、评论、追踪修订等，都经过了商业化验证。
	- **文档和支持完善**: 作为商业产品，其文档、API 和技术支持都非常专业。
	- **协同基于 ProseMirror**: 底层技术先进，协同编辑体验非常出色。
- **缺点**:
	- **成本高昂**: 其协同编辑和评论等关键功能均属于**付费商业授权**，对于内部项目来说成本较高。
	- **后端绑定**: 其协同功能需要配合其官方提供的云服务或本地部署的协同服务器，与我们自研后端的集成模式不完全匹配。

### 2.3. 框架自研路线分析
在调研了组件集成方案后，我们发现它们在**定制性和与内部系统融合度**方面均无法完全满足我们的长期目标。因此，我们深入研究了基于框架自研的路线。
#### 2.3.1. ShareDB 路线 (OT) - **首选方案**

**ShareDB** 是一个用于实现实时同步和协同的后端“引擎”或“框架”。它提供了一套基于 OT (Operational Transformation) 的机制来同步任意 JSON 数据结构。

-   **工作模式**:
    1.  **后端**: 开发者使用 ShareDB 库搭建一个 WebSocket 服务器。
    2.  **数据模型**: ShareDB 同步的是 JSON 对象（`doc`）。对于富文本，需要将编辑器的内容模型（如 Quill Delta 或 Prosemirror JSON）作为这个 `doc`。
    3.  **前端**: 开发者需要自己选择并集成一个富文本编辑器（如 Quill.js, Prosemirror），并编写“胶水代码”，将编辑器的操作（`ops`）与 ShareDB 的客户端库进行双向绑定。

-   **优点**:
    -   **极高的灵活性**: 不局限于富文本，可以同步任何 JSON 数据，适用于协同绘图、协同表单、看板等多种复杂场景。
    -   **原生集成**: 协同能力可以“原生”地融入前端应用状态，与现代前端框架（React/Vue）结合更紧密，体验更佳。
    -   **高性能**: 架构现代，专为大规模并发设计。

-   **缺点**:
    -   **开发成本高**: 它是一个底层框架，而非开箱即用的应用。需要大量的前后端开发工作，包括：
        -   自主选择、集成和定制前端富文本编辑器。
        -   编写复杂的前后端数据绑定和操作转换逻辑。
        -   自行实现用户状态同步。
        -   自行实现版本历史的存储和恢复逻辑。
    -   **学习曲线陡峭**: 需要深入理解 OT 算法、编辑器数据模型以及 ShareDB 自身的概念。
#### 2.3.2. Y.js 路线 (CRDT) 

- **简介**: 一个基于 CRDT 算法的前端协同框架，拥有极其活跃和成熟的生态。
- **核心技术栈**: 
	- **前端**: **Tiptap** (编辑器) + **Y.js** (协同引擎) + **y-prosemirror** (绑定库)
	- **后端**: **Hocuspocus** (Y.js 的生产级实时后端框架)
- **优点**:
	- **极致的定制性和原生体验**: Tiptap 作为“无头”编辑器，允许我们用 React 和 Ant Design 构建**任何想要的 UI**，实现与语雀完全一致的原生体验。
	- **前端生态完美**: `y-prosemirror` 库提供了 Tiptap/ProseMirror 与 Y.js 之间无缝、高效的绑定，**完美解决了前端集成的最大难题**。
	- **性能卓越且离线友好**: CRDT 算法在处理并发编辑和网络不佳、离线后同步等场景时表现出色。
	- **后端解决方案成熟**: **Hocuspocus** 框架专门为 Y.js 设计，提供了**开箱即用的持久化、认证、授权等企业级功能**的扩展和钩子。
- **缺点**:
	- **成本高昂**: 其协同编辑和评论等关键功能均属于**付费商业授权**，对于内部项目来说成本较高。
	- **后端绑定**: 其协同功能需要配合其官方提供的云服务或本地部署的协同服务器，与我们自研后端的集成模式不完全匹配。
#### 2.3.3 集成方案：Etherpad

**Etherpad** 是一个开源的、功能完备的实时协同编辑器应用。

-   **工作模式**:
    -   部署一个独立的 Etherpad 服务。
    -   通过 API 和 `<iframe>` 将其完整的编辑器功能嵌入到主应用中。

-   **优点**:
    -   **开箱即用**: 自带稳定、功能丰富的前端编辑器和成熟的协同后端，极大降低了开发成本。
    -   **功能完备**: 原生支持用户身份识别、版本历史回放、聊天等协同必备功能。
    -   **生态成熟**: 拥有庞大的插件库，可轻松扩展表格、Markdown、评论等功能。
    -   **易于集成**: API 简单清晰，主要工作集中在权限和会话管理，而非复杂的协同逻辑。

### 2.3. 选型结论

| 对比维度      | Etherpad (完整应用) | ShareDB (底层框架) | Y.js (底层框架)    | **本项目适配性**                                                                 |
| :-------- | :-------------- | :------------- | -------------- | :------------------------------------------------------------------------- |
| **产品形态**  | 功能齐全的房车         | 引擎+底盘          | 引擎+底盘          | **ShareDB方便集成现有系统**                                                        |
| **核心能力**  | 协同编辑富文本         | 同步任意 JSON      | 同步任意 JSON，离线编辑 | 项目核心需求是富文本，三者都可以胜任                                                         |
| **开发成本**  | 低               | 高              | 高              | 均可以做到基础功能实现                                                                |
| **灵活性**   | 低（通过插件扩展）       | 极高             | 极高             | 项目需要一定的灵活性                                                                 |
| **功能完备性** | 高（开箱即用）         | 低（需自研）         | 中（需自研,扩展生态较多）  | **ShareDB已经有线上项目实践经验**                                                     |
| **加载性能**  | 高               | 高              | 低              | **ShareDB的结果直接存储在kv结构中，加载和渲染很快，Y.js包含全部元信息的整个数据结构是结果，在前后端的任何位置都需要额外的数据传输** |

**结论**: 本项目的核心是**协同文档编辑**，而非更广义的协同应用。 经过对主流协同编辑技术方案（Y.js/CRDT、Etherpad、ShareDB/OT）的深入研究与对比，首选是 **ShareDB (基于 OT 算法)** 作为本项目的核心后端协作引擎。此选择基于以下关键考量：
**1. 完美契合“精简与集成”的产品定位：**

- **ShareDB 的库（Library）定位：** ShareDB 并非一个大而全的应用或框架，而是一个专注的后端协作引擎。这使得我们能将其作为“心脏”轻松嵌入到自定义的应用架构中，与我们的账号中心、权限系统和业务逻辑无缝融合，而不是在其原有系统上做痛苦的修改。
    
- **OT 模型的逻辑清晰性：** 操作转换（Operational Transformation, OT）的中心化模型，确保了所有操作都经过服务器的权威仲裁。这种线性的、可预测的数据流模型，更易于理解、调试和控制，完全符合我们追求“精简”和“稳定”的产品哲学。
    

**2. 核心优势最大化，规避商业产品短板：**

- **主场优势最大化（集成能力）：** ShareDB 的中间件（Middleware）机制为集成账号中心提供了完美的切入点。我们可以在用户连接和操作的各个阶段，轻松植入自定义的认证（Authentication）与授权（Authorization）逻辑，实现与账号中心联动的、精细化的权限管控。这是外部商业产品无法比拟的核心优势。
    
- **规避“功能臃肿”陷阱：** 公司内部已经提供了功能繁杂的商业产品（**小闪文档**），选择 ShareDB 让我们能从一个轻量的核心出发，按需添加功能。这保障了产品的**快速加载**和**极致性能**，形成了与外部产品的显著差异化体验。
    

**3. 技术风险与成本可控：**

- **学习曲线适中：** 相较于需要深入理解 CRDT 复杂数据结构和合并算法的 Y.js，OT 的心智模型更贴近传统的客户端/服务器架构，开发团队的学习和上手成本更低，能够更快地投入到业务开发中。
    
- **成熟稳定：** ShareDB 源自 Google Wave，其核心 OT 算法经过了长时间的实践检验，且目前已有线上产品的相应实践，可有效降低项目在核心功能上的技术风险。

## 3. 系统架构设计

系统采用分层架构，清晰地分离了前端、后端业务逻辑和依赖服务。


*（这是一个描述性的图示，您可以自行绘制更详细的架构图）*

1.  **前端层 (UI/UX)**: 用户直接交互的界面，负责页面渲染和用户操作响应。
2.  **后端应用层 (Wiki Service)**: 系统的“大脑”，负责处理所有业务逻辑。
3.  **依赖服务层**:
    -   **公司内部服务**: 账号中心 (SSO)、项目中心。
    -   **核心组件服务**: 本次部署的 Sharedb协同服务和http服务。

### 3.1. 交互流程

1.  用户通过浏览器访问 **Wiki 前端**。
2.  前端通过 RESTful API 与 **Wiki 后端** 通信。
3.  Wiki 后端负责：
    -   调用 **账号中心 API** 进行用户身份验证。
    -   调用 **项目中心 API** 获取项目及成员信息，用于权限判断。
    -   操作 **Wiki 自身数据库** 管理知识库、文档目录等元数据。
    -   调用 **ShareDB** 创建和管理协同会话。
4.  **ShareDB** 服务独立运行，通过 ws 向前端传输数据。

## 4. 功能模块拆解

### 4.1. 模块一：用户认证集成

-   **需求**: 对接统一账号中心，实现单点登录 (SSO)。
-   **实现**:
    1.  前端引导用户至账号中心登录。
    2.  后端通过授权码 (`code`) 或令牌 (`token`) 从账号中心获取用户信息，完成登录态建立。

### 4.2. 模块二：知识库与文档目录

-   **需求**: 提供结构化的知识管理能力，关联项目，支持树状目录。
-   **实现**:
    1.  **数据库设计**:
        -   `knowledge_bases` (知识库表): 关联 `project_id`和 doc_id。
    2.  **后端 API**: 提供对知识库和文档的增删改查接口。
    3.  **前端界面**: 提供知识库创建、管理以及可拖拽的文档树组件。

### 4.3. 模块三：权限管理

-   **需求**: 实现基于项目成员的角色权限控制（管理员、编辑者、只读者）。
-   **实现**:
    1.  **权限数据源**: 以项目中心的数据为准。
    2.  **访问控制**: 后端建立权限检查中间件，在每次 API 请求时，实时调用项目中心 API 或查询权限缓存，验证用户操作权限。

### 4.4. 模块四：协同编辑集成 (核心)

-   **需求**: 在文档页加载可多人实时编辑的编辑器。
-   **实现**:
    1.  **部署**: 独立部署 ShareDB 服务，配置好数据库。
    2.  **后端 API (`/api/docs/:docId/session`)**:
        -   接收前端请求，进行权限校验。
        -   从数据库查询文档对应的 `doc_id` 和所属项目的 `project_id`。
        -   调用 鉴权逻辑 API，创建会话并获取 `sessionID`。
    3.  **前端逻辑**:
        -   调用上述 API 获取 `sessionID`。
        -   使用 将 `sessionID` 设置到 Cookie 中。
        -   带上Cookie升级http到ws。

### 4.5. 模块五：版本历史

-   **需求**: 支持查看和恢复文档的历史版本。
-   **实现**:
    1.  **后端实现API**: 通过历史操作重建doc或者使用定期快照恢复doc。
    2.  **前端界面**: 提供“历史记录”入口，展示版本列表，并允许用户恢复到指定版本。

## 5. 后端框架以及数据库选型


### 5.1. python + mysql + mongodb
- **MySQL：** 存储 documents 业务元数据表。
- **MongoDB：** 专门给 ShareDB 使用，存储 c_documents 和 o_documents。

#### 优点（为什么这是“更专业”的选择）：

- **优点**:
    
    - **发挥各自长处：** 让正确的技术做正确的事。MySQL 极其擅长处理结构化的、关系性强的数据和复杂事务，非常适合管理你的业务核心数据。MongoDB 则专门负责它擅长的、由 ShareDB 产生的半结构化文档和高频写入的操作日志。
        
    - **保持核心业务稳定：** 公司的核心业务数据仍然由团队最熟悉的、最稳健的 MySQL 来保障。
        
2. **利用现有经验：** 团队无需学习新的数据库技术，可以直接利用现有的 MySQL 知识、工具和运维经验，开发效率和稳定性都有保障。
    

- **潜在缺点与风险**:

1. **架构复杂度显著增加：**
    
    - **维护两种数据库：** 你需要同时部署、监控、备份 MySQL 和 MongoDB。
        
    - **管理两个连接池：** 你的 Node.js 应用需要同时维护到两种数据库的连接，代码会更复杂。
        
    - **跨库数据一致性：** 虽然不常见，但如果某个操作需要同时写入 MySQL 和 MongoDB，你将面临分布式事务的挑战，需要通过额外的编码来保证数据最终一致性。
        
    - **开发体验割裂：** 开发者需要在两种不同的数据查询和操作方式之间切换思维（SQL vs. MQL）。

### 5.2. nestjs + mongodb

将项目、文档等业务相关设计的 documents（业务元数据）表也放在 MongoDB 中。

- **优点**:

1. **技术栈统一，降低运维成本：**
    
    - **单一数据库技术：** 只需要学习、部署、监控和备份一种数据库（MongoDB），无需引入多种数据库以及依赖，能极大地降低认知负担和运维成本。
        
    - **连接池和驱动统一：**  Node.js 应用只需要维护一个到 MongoDB 的数据库连接池，代码更简洁。
        
2. **开发效率高，与 Node.js 生态完美契合：**
    
    - **JSON 原生亲和：** JavaScript/Node.js 处理 JSON 对象是天生的。将 JSON 格式的业务数据直接存入 MongoDB，无需像操作 MySQL 那样进行 ORM（对象关系映射）的转换，心智模型更统一，代码更直观（例如使用 Mongoose）。
        
    - **灵活的 Schema：** MongoDB 的 Schemaless（或称动态 Schema）特性非常适合敏捷开发和快速迭代。当你需要为 documents 表增加一个新字段（比如“标签”tags），不需要像 MySQL 那样执行 ALTER TABLE，可以直接在代码中添加，旧数据不受影响。
        
3. **性能对于业务元数据足够：**
    
    - 对于文档元数据管理这类场景（读写文档列表、权限等），不涉及复杂的事务和多表关联。MongoDB 的单文档原子性和强大的索引能力，完全可以提供非常高的性能。


- **潜在缺点与风险**:

- **事务能力较弱：** 虽然 MongoDB 4.0 之后引入了多文档事务，但其能力和易用性仍然不如传统的关系型数据库。如果业务逻辑包含需要跨多个集合（表）的复杂事务（例如，创建文档的同时，插入进度、写入项目日志等强一致性操作），使用 MongoDB 会更复杂。
    
- **团队熟悉度：**  MySql熟悉程度比较高，MongoDB 有一定的的学习成本，可能会踩一些坑（比如不合理的索引设计、不理解聚合管道等）。


## 6. 风险与预案

-   **风险**: Etherpad 插件质量参差不齐，或无法满足高度定制化的需求。
-   **预案**: 优先使用官方和社区推荐的稳定插件。对于关键的定制化需求，预留前端开发资源进行二次开发或样式覆盖。

-   **风险**: `<iframe>` 的跨域问题和体验限制。
-   **预案**: 仔细处理 Cookie 的 `domain` 和 `SameSite` 属性。设计加载动画以优化 `<iframe>` 加载时的白屏体验。